{
  "version": 3,
  "sources": ["../hiragana.ts", "../adjective.ts", "../index.ts"],
  "sourcesContent": ["const split = (s: string) => s.split(\"\");\nconst vec = [\n  split(\"\u3042\u3044\u3046\u3048\u304A\"),\n  split(\"\u304B\u304D\u304F\u3051\u3053\"),\n  split(\"\u304C\u304E\u3050\u3052\u3054\"),\n  split(\"\u3055\u3057\u3059\u305B\u305D\"),\n  split(\"\u3056\u3058\u305A\u305C\u305E\"),\n  split(\"\u305F\u3061\u3064\u3066\u3068\"),\n  split(\"\u3060\u3062\u3065\u3067\u3069\"),\n  split(\"\u306A\u306B\u306C\u306D\u306E\"),\n  split(\"\u306F\u3072\u3075\u3078\u307B\"),\n  split(\"\u3070\u3073\u3076\u3079\u307C\"),\n  split(\"\u3071\u3074\u3077\u307A\u307D\"),\n  split(\"\u307E\u307F\u3080\u3081\u3082\"),\n  [\"\u3084\", \"\", \"\u3086\", \"\", \"\u3088\"],\n  split(\"\u3089\u308A\u308B\u308C\u308D\"),\n  [\"\u308F\", \"\", \"\", \"\", \"\u3092\"],\n  [\"\u3093\", \"\", \"\", \"\", \"\"],\n];\nlet charToVecIndex: Map<String, number> = new Map([]);\nvec.forEach((row, rowidx) => {\n  row.forEach((char) => {\n    if (char.length > 0) {\n      charToVecIndex.set(char, rowidx);\n    }\n  });\n});\nexport function lookup(character: String, vowel: number): String {\n  if (vowel < 0 || vowel > 4) {\n    throw new Error(\"vowel must be between 0 and 4\");\n  }\n  const idx = charToVecIndex.get(character);\n  if (typeof idx === \"undefined\") {\n    throw new Error(\"unknown character\");\n  }\n  const ret = vec[idx][vowel];\n  if (ret.length === 0) {\n    throw new Error(\"vowel for kana does not exist\");\n  }\n  return ret;\n}\n", "export const adjConjugations = [\n  \"Present\",\n  \"Prenomial\",\n  \"Negative\",\n  \"Past\",\n  \"NegativePast\",\n  \"ConjunctiveTe\",\n  \"Adverbial\",\n  \"Conditional\",\n  \"TaraConditional\",\n  \"Tari\",\n  \"Noun\",\n  \"StemSou\",\n  \"StemNegativeSou\",\n] as const;\nexport type AdjConjugation = (typeof adjConjugations)[number];\n\nfunction never(x: never) {\n  throw new Error(\"never?\");\n}\n\nexport function adjConjugate(\n  adjective: string,\n  conj: AdjConjugation,\n  iAdjective: boolean,\n): string[] {\n  if (iAdjective) {\n    let stem = adjective.slice(0, -1);\n    let addSa = false;\n    if (adjective === \"\u3044\u3044\" || adjective === \"\u826F\u3044\" || adjective === \"\u3088\u3044\") {\n      stem = adjective.startsWith(\"\u826F\") ? \"\u826F\" : \"\u3088\";\n      addSa = true;\n    } else if (adjective.endsWith(\"\u306A\u3044\")) {\n      addSa = true;\n    }\n    switch (conj) {\n      case \"Present\":\n        return [adjective];\n      case \"Prenomial\":\n        return [adjective];\n      case \"Negative\":\n        return [stem + \"\u304F\u306A\u3044\"];\n      case \"Past\":\n        return [stem + \"\u304B\u3063\u305F\"];\n      case \"NegativePast\":\n        return [stem + \"\u304F\u306A\u304B\u3063\u305F\"];\n      case \"ConjunctiveTe\":\n        return [stem + \"\u304F\", stem + \"\u304F\u3066\"];\n      case \"Adverbial\":\n        return [stem + \"\u304F\"];\n      case \"Conditional\":\n        return [stem + \"\u3051\u308C\u3070\"];\n      case \"TaraConditional\":\n        return [stem + \"\u304B\u3063\u305F\u3089\"];\n      case \"Tari\":\n        return [stem + \"\u304B\u3063\u305F\u308A\"];\n      case \"Noun\":\n        return [stem + \"\u3055\"];\n      case \"StemSou\":\n        return [addSa ? stem + \"\u3055\u305D\u3046\" : stem + \"\u305D\u3046\"];\n      case \"StemNegativeSou\": {\n        const negativeStem = stem + \"\u304F\u306A\";\n        // basically conjugate adjective with 'Negative' and redo stem\n        return [negativeStem + \"\u3055\u305D\u3046\"];\n      }\n      default:\n        never(conj);\n    }\n  }\n  // na-adjective\n  switch (conj) {\n    case \"Prenomial\":\n      return [adjective + \"\u306A\"];\n    case \"Present\":\n      return [\"\u3060\", \"\u3067\u3059\", \"\u3067\u3054\u3056\u3044\u307E\u3059\"].map((suffix) => adjective + suffix);\n    case \"Negative\":\n      return [\"\u3067\u306F\u306A\u3044\", \"\u3067\u306A\u3044\", \"\u3058\u3083\u306A\u3044\", \"\u3067\u306F\u3042\u308A\u307E\u305B\u3093\"].map(\n        (suffix) => adjective + suffix,\n      );\n    case \"Past\":\n      return [\"\u3060\u3063\u305F\", \"\u3067\u3057\u305F\"].map((suffix) => adjective + suffix);\n    case \"NegativePast\":\n      return [\n        \"\u3067\u306F\u306A\u304B\u3063\u305F\",\n        \"\u3067\u306A\u304B\u3063\u305F\",\n        \"\u3058\u3083\u306A\u304B\u3063\u305F\",\n        \"\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3067\u3057\u305F\",\n      ].map((suffix) => adjective + suffix);\n    case \"ConjunctiveTe\":\n      return [adjective + \"\u3067\"];\n    case \"Adverbial\":\n      return [adjective + \"\u306B\"];\n    case \"Conditional\":\n      return [\"\u306A\u3089\", \"\u306A\u3089\u3070\"].map((suffix) => adjective + suffix);\n    case \"TaraConditional\":\n      return [\"\u3060\u3063\u305F\u3089\"].map((suffix) => adjective + suffix);\n    case \"Tari\":\n      return [\"\u3060\u3063\u305F\u308A\", \"\u3067\u3057\u305F\u308A\"].map((suffix) => adjective + suffix);\n    case \"Noun\":\n      return [adjective + \"\u3055\"];\n    case \"StemSou\":\n      return [adjective + \"\u305D\u3046\"];\n    case \"StemNegativeSou\":\n      return [adjective + \"\u3058\u3083\u306A\u3055\u305D\u3046\"];\n    default:\n      never(conj);\n  }\n\n  throw new Error(\"unknown conjugation/iAdjective\");\n}\n\nexport interface AdjDeconjugated {\n  conjugation: AdjConjugation;\n  result: string[];\n}\nexport function adjDeconjugate(\n  conjugated: string,\n  dictionary: string,\n  iAdjective: boolean,\n): AdjDeconjugated[] {\n  const hits: AdjDeconjugated[] = [];\n  for (const conj of adjConjugations) {\n    const result = adjConjugate(dictionary, conj, iAdjective);\n    if (result.includes(conjugated)) {\n      hits.push({ conjugation: conj, result });\n    }\n  }\n  return hits;\n}\n", "import { lookup } from \"./hiragana\";\n\nexport const conjugations = [\n  \"Negative\",\n  \"Conjunctive\",\n  \"Dictionary\",\n  \"Conditional\",\n  \"Imperative\",\n  \"Volitional\",\n  \"Te\",\n  \"Ta\",\n  \"Tara\",\n  \"Tari\",\n  \"Zu\", // Not in Kamiya: classical negative\n  \"Nu\", // Not in Kamiya: classical negative (attributive form of Zu)\n] as const;\nexport type Conjugation = (typeof conjugations)[number];\n\nexport const auxiliaries = [\n  \"Potential\",\n  \"Masu\",\n  \"Nai\",\n  \"Tai\",\n  \"Tagaru\",\n  \"Hoshii\",\n  \"Rashii\",\n  \"SoudaHearsay\",\n  \"SoudaConjecture\",\n  \"SeruSaseru\",\n  \"ShortenedCausative\",\n  \"ReruRareru\",\n  \"CausativePassive\",\n  \"ShortenedCausativePassive\",\n  \"Ageru\", // Kamiya section 7.15\n  \"Sashiageru\",\n  \"Yaru\",\n  \"Morau\", // Kamiya section 7.16\n  \"Itadaku\",\n  \"Kureru\", // Kamiya section 7.17\n  \"Kudasaru\",\n  \"TeIru\", // 7.5 - 7.6\n  \"TeAru\", // 7.7\n  \"Miru\", // 7.22\n  \"Iku\", // 7.23\n  \"Kuru\", // 7.24\n  \"Oku\", // 7.25\n  \"Shimau\", // 7.26\n  \"TeOru\", // Not in Kamiya\n] as const;\nexport type Auxiliary = (typeof auxiliaries)[number];\n\nconst specialCasesRaw: Array<[string, Conjugation, string]> = [\n  [\"\u3042\u308B\", \"Negative\", \"\"], // fully negative conjugation would be ''+nai\n  [\"\u3054\u3056\u308B\", \"Conjunctive\", \"\u3054\u3056\u3044\"],\n  [\"\u3044\u3089\u3063\u3057\u3083\u308B\", \"Conjunctive\", \"\u3044\u3089\u3063\u3057\u3083\u3044\"],\n  [\"\u3044\u3089\u3063\u3057\u3083\u308B\", \"Conditional\", \"\u3044\u3089\u3063\u3057\u3083\u3044\"],\n  [\"\u3044\u3089\u3063\u3057\u3083\u308B\", \"Imperative\", \"\u3044\u3089\u3063\u3057\u3083\u3044\"],\n];\nlet specialCases: Map<string, Map<Conjugation, string>> = new Map([]);\nfor (const [verb, conj, result] of specialCasesRaw) {\n  let outer = specialCases.get(verb);\n  if (outer) {\n    outer.set(conj, result);\n  } else {\n    specialCases.set(verb, new Map([[conj, result]]));\n  }\n}\nconst conjToIdx: Map<Conjugation, number> = new Map(\n  conjugations.filter((x) => x !== \"Imperative\").map((x, i) => [x, i]) as Array<\n    [Conjugation, number]\n  >,\n);\nconjToIdx.set(\"Zu\", conjToIdx.get(\"Negative\") ?? -1);\nconjToIdx.set(\"Nu\", conjToIdx.get(\"Negative\") ?? -1);\n\nconst tteRaw: Array<[string, string[]]> = [\n  [\"\u304F\", [\"\u3044\u3066\", \"\u3044\u305F\", \"\u3044\u305F\u3089\", \"\u3044\u305F\u308A\"]],\n  [\"\u3050\", [\"\u3044\u3067\", \"\u3044\u3060\", \"\u3044\u3060\u3089\", \"\u3044\u3060\u308A\"]],\n  [\"\u3059\", [\"\u3057\u3066\", \"\u3057\u305F\", \"\u3057\u305F\u3089\", \"\u3057\u305F\u308A\"]],\n  [\"\u306C\", [\"\u3093\u3067\", \"\u3093\u3060\", \"\u3093\u3060\u3089\", \"\u3093\u3060\u308A\"]],\n  [\"\u3076\", [\"\u3093\u3067\", \"\u3093\u3060\", \"\u3093\u3060\u3089\", \"\u3093\u3060\u308A\"]], // same as above\n  [\"\u3080\", [\"\u3093\u3067\", \"\u3093\u3060\", \"\u3093\u3060\u3089\", \"\u3093\u3060\u308A\"]], // ditto\n  [\"\u3064\", [\"\u3063\u3066\", \"\u3063\u305F\", \"\u3063\u305F\u3089\", \"\u3063\u305F\u308A\"]],\n  [\"\u308B\", [\"\u3063\u3066\", \"\u3063\u305F\", \"\u3063\u305F\u3089\", \"\u3063\u305F\u308A\"]], // same as above and below\n  [\"\u3046\", [\"\u3063\u3066\", \"\u3063\u305F\", \"\u3063\u305F\u3089\", \"\u3063\u305F\u308A\"]],\n];\nlet tte: Map<string, string[]> = new Map([]);\nfor (const [tail, quad] of tteRaw) {\n  tte.set(tail, quad);\n}\n\nexport function conjugateTypeI(verb: string, conj: Conjugation): string[] {\n  {\n    if (verb === \"\u3059\u308B\") {\n      return conjugateSuru(verb, conj);\n    } else if (verb === \"\u304F\u308B\" || verb === \"\u6765\u308B\") {\n      return conjugateKuru(verb, conj);\n    } else if (verb === \"\u3060\") {\n      return conjugateDa(verb, conj);\n    } else if (verb === \"\u3067\u3059\") {\n      return conjugateDesu(verb, conj);\n    } else if (verb.endsWith(\"\u304F\u3060\u3055\u308B\")) {\n      if (conj === \"Dictionary\") {\n        return [verb];\n      } else if (conj === \"Conjunctive\") {\n        return [verb.slice(0, -2) + \"\u3055\u3044\"];\n      } else {\n        throw new Error(\"unknown conjugation for -kudasaru\");\n      }\n    }\n    const specialHit = specialCases.get(verb);\n    if (specialHit && specialHit.has(conj)) {\n      return [specialHit.get(conj) || \"\"];\n    }\n    // The above inner-most `get` is guaranteed to be not-undefined, so the empty string will never be returned, but\n    // TypeScript 3.0.1 doesn't treat `Map.has` as a type guard \uD83D\uDE23.\n  }\n  const head = verb.slice(0, -1);\n  const tail = verb.slice(-1);\n  const idx = conjToIdx.get(conj === \"Imperative\" ? \"Conditional\" : conj);\n  if (typeof idx === \"undefined\") {\n    throw new Error(\"Conjugation not yet implemented\");\n  }\n  if (idx < 5) {\n    if (tail === \"\u3046\") {\n      if (idx === 0) {\n        return [head + \"\u308F\"];\n      }\n      return [head + lookup(\"\u3042\", idx)];\n    }\n    return [head + lookup(tail, idx)];\n  }\n  const tidx = idx - 5;\n  const tteHit = tte.get(verb === \"\u884C\u304F\" || verb === \"\u3044\u304F\" ? \"\u3064\" : tail);\n  if (!tteHit) {\n    throw new Error(\"Unknown verb ending. Is it in dictionary form?\");\n  }\n  return [head + tteHit[tidx]];\n}\n\nexport function conjugateTypeII(verb: string, conj: Conjugation): string[] {\n  if (verb === \"\u3059\u308B\") {\n    return conjugateSuru(verb, conj);\n  } else if (verb === \"\u304F\u308B\" || verb === \"\u6765\u308B\") {\n    return conjugateKuru(verb, conj);\n  } else if (verb === \"\u3060\") {\n    return conjugateDa(verb, conj);\n  } else if (verb === \"\u3067\u3059\") {\n    return conjugateDesu(verb, conj);\n  }\n  const head = verb.slice(0, -1);\n  switch (conj) {\n    case \"Negative\":\n    case \"Zu\":\n    case \"Nu\":\n      return [head];\n    case \"Conjunctive\":\n      return [head];\n    case \"Dictionary\":\n      return [verb];\n    case \"Conditional\":\n      return [head + \"\u308C\"];\n    case \"Imperative\":\n      return [head + \"\u308D\", head + \"\u3088\"];\n    case \"Volitional\":\n      return [head + \"\u3088\u3046\"];\n    case \"Te\":\n      return [head + \"\u3066\"];\n    case \"Ta\":\n      return [head + \"\u305F\"];\n    case \"Tara\":\n      return [head + \"\u305F\u3089\"];\n    case \"Tari\":\n      return [head + \"\u305F\u308A\"];\n    default:\n      throw new Error(\"Unhandled conjugation\");\n  }\n}\n\nfunction conjugateKuru(verb: string, conj: Conjugation): string[] {\n  let ret = \"\";\n  switch (conj) {\n    case \"Negative\":\n    case \"Zu\":\n    case \"Nu\":\n      ret = \"\u3053\";\n      break;\n    case \"Conjunctive\":\n      ret = \"\u304D\";\n      break;\n    case \"Dictionary\":\n      ret = \"\u304F\u308B\";\n      break;\n    case \"Conditional\":\n      ret = \"\u304F\u308C\";\n      break;\n    case \"Imperative\":\n      ret = \"\u3053\u3044\";\n      break;\n    case \"Volitional\":\n      ret = \"\u3053\u3088\u3046\";\n      break;\n    case \"Te\":\n      ret = \"\u304D\u3066\";\n      break;\n    case \"Ta\":\n      ret = \"\u304D\u305F\";\n      break;\n    case \"Tara\":\n      ret = \"\u304D\u305F\u3089\";\n      break;\n    case \"Tari\":\n      ret = \"\u304D\u305F\u308A\";\n      break;\n    default:\n      throw new Error(\"Unhandled conjugation\");\n  }\n  const head = verb.slice(0, -1);\n  if (head === \"\u304F\") {\n    return [ret];\n  } else if (head === \"\u6765\") {\n    return [\"\u6765\" + ret.slice(1)];\n  }\n  throw new Error(\"Expected input to be \u6765\u308B or \u304F\u308B\");\n}\n\nfunction conjugateSuru(verb: string, conj: Conjugation): string[] {\n  switch (conj) {\n    case \"Negative\":\n      return [\"\u3057\"];\n    case \"Conjunctive\":\n      return [\"\u3057\"];\n    case \"Dictionary\":\n      return [\"\u3059\u308B\"];\n    case \"Conditional\":\n      return [\"\u3059\u308C\"];\n    case \"Imperative\":\n      return [\"\u3057\u308D\", \"\u305B\u3088\"];\n    case \"Volitional\":\n      return [\"\u3057\u3088\u3046\"];\n    case \"Te\":\n      return [\"\u3057\u3066\"];\n    case \"Ta\":\n      return [\"\u3057\u305F\"];\n    case \"Tara\":\n      return [\"\u3057\u305F\u3089\"];\n    case \"Tari\":\n      return [\"\u3057\u305F\u308A\"];\n    case \"Zu\":\n      return [\"\u305B\u305A\"];\n    case \"Nu\":\n      return [\"\u305B\u306C\"];\n    default:\n      throw new Error(\"Unhandled conjugation\");\n  }\n}\nfunction conjugateDa(_verb: string, conj: Conjugation): string[] {\n  switch (conj) {\n    case \"Negative\":\n      return [\"\u3067\u306A\u3044\", \"\u3067\u306F\u306A\u3044\", \"\u3058\u3083\u306A\u3044\"];\n    case \"Dictionary\":\n      return [\"\u3060\"];\n    case \"Conditional\":\n      return [\"\u306A\u3089\"];\n    // case 'Presumptive': return ['\u3060\u308D\u3046']; // omitting this\n    case \"Te\":\n      return [\"\u3067\"];\n    case \"Ta\":\n      return [\"\u3060\u3063\u305F\"];\n    case \"Tara\":\n      return [\"\u3060\u3063\u305F\u3089\"];\n    case \"Tari\":\n      return [\"\u3060\u3063\u305F\u308A\"];\n    default:\n      throw new Error(\"Unhandled conjugation\");\n  }\n}\nfunction conjugateDesu(_verb: string, conj: Conjugation): string[] {\n  switch (conj) {\n    case \"Negative\":\n      return [\"\u3067\u3042\u308A\u307E\u305B\u3093\", \"\u3067\u306F\u3042\u308A\u307E\u305B\u3093\"];\n    case \"Dictionary\":\n      return [\"\u3067\u3059\"];\n    // case 'Presumptive': return ['\u3067\u305D\u3046']; // omitting this\n    case \"Te\":\n      return [\"\u3067\u3057\u3066\"];\n    case \"Ta\":\n      return [\"\u3067\u3057\u305F\"];\n    case \"Tara\":\n      return [\"\u3067\u3057\u305F\u3089\"];\n    case \"Tari\":\n      return [\"\u3067\u3057\u305F\u308A\"];\n    default:\n      throw new Error(\"Unhandled conjugation\");\n  }\n}\n\nfunction conjugateStrict(\n  verb: string,\n  conj: Conjugation,\n  typeII: boolean = false,\n): string[] {\n  return (verb.slice(-1) === \"\u308B\" && typeII ? conjugateTypeII : conjugateTypeI)(\n    verb,\n    conj,\n  );\n}\n\nexport function conjugate(\n  verb: string,\n  conj: Conjugation,\n  typeII = false,\n): string[] {\n  const ret = conjugateStrict(verb, conj, typeII);\n\n  if (\n    (conj === \"Negative\" || conj === \"Zu\" || conj === \"Nu\") &&\n    verb !== \"\u3060\" &&\n    verb !== \"\u3067\u3059\"\n  ) {\n    // Don't do this for da/desu because their negatives are baked in\n    if (conj === \"Negative\") {\n      ret.push(ret[0] + \"\u306A\u3044\");\n    } else if (conj === \"Zu\") {\n      ret.push(ret[0] + \"\u305A\");\n    } else if (conj === \"Nu\") {\n      ret.push(ret[0] + \"\u306C\");\n    }\n  } else if (conj === \"Conjunctive\") {\n    ret.push(ret[0] + \"\u307E\u3059\");\n  } else if (conj === \"Conditional\") {\n    ret.push(ret[0] + \"\u3070\");\n  } else if (conj === \"Volitional\") {\n    ret.push(ret[0] + \"\u3046\");\n  }\n\n  return ret;\n}\n\nexport function conjugateAuxiliaries(\n  initialVerb: string,\n  auxs: Auxiliary[],\n  finalConj: Conjugation,\n  initialTypeII: boolean = false,\n): string[] {\n  if (auxs.length === 0) {\n    return conjugate(initialVerb, finalConj, initialTypeII);\n  }\n\n  if (initialVerb === \"\u3060\" || initialVerb === \"\u3067\u3059\") {\n    if (auxs.length === 1 && auxs[0] === \"Nai\") {\n      if (finalConj === \"Ta\") {\n        if (initialVerb === \"\u3060\") {\n          return [\"\u3067\u306F\u306A\u304B\u3063\u305F\", \"\u3058\u3083\u306A\u304B\u3063\u305F\"];\n        } else {\n          return [\"\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3067\u3057\u305F\", \"\u3067\u3042\u308A\u307E\u305B\u3093\u3067\u3057\u305F\"];\n        }\n      } else if (finalConj === \"Te\" && initialVerb === \"\u3060\") {\n        return [\"\u3058\u3083\u306A\u304F\u3066\"];\n      }\n    }\n    throw new Error(\"unhandled copula auxiliaries/conjugation\");\n  }\n\n  let verbs: string[] = [initialVerb];\n  let typeII = initialTypeII;\n  for (const [auxIdx, aux] of auxs.entries()) {\n    const conj: Conjugation =\n      auxIdx === auxs.length - 1 ? finalConj : \"Dictionary\";\n    const prevAux: Auxiliary | undefined = auxs[auxIdx - 1];\n\n    if (\n      auxIdx !== auxs.length - 1 &&\n      (aux === \"Masu\" ||\n        aux === \"Nai\" ||\n        aux === \"Tai\" ||\n        aux == \"Hoshii\" ||\n        aux === \"Rashii\" ||\n        aux === \"SoudaConjecture\" ||\n        aux === \"SoudaHearsay\")\n    ) {\n      throw new Error(\"must be final auxiliary\");\n    }\n\n    if (prevAux === \"Kuru\") {\n      // While `conjugate` looks for with Kudasaru with `endsWith`, it looks for Kuru with exact-compare (because\n      // potentially lots of things could end in kuru)\n      const heads = verbs.map((s) => s.slice(0, -2));\n      const tails = conjugateAuxiliary(\"\u304F\u308B\", aux, conj);\n      verbs = heads.flatMap((prefix) => tails.map((t) => prefix + t));\n    } else {\n      verbs = verbs.flatMap((verb) =>\n        conjugateAuxiliary(verb, aux, conj, typeII),\n      );\n    }\n    typeII =\n      aux === \"Potential\" ||\n      aux === \"SeruSaseru\" ||\n      aux === \"ReruRareru\" ||\n      aux === \"CausativePassive\" ||\n      aux === \"ShortenedCausativePassive\" ||\n      aux === \"Ageru\" ||\n      aux === \"Sashiageru\" ||\n      aux === \"Kureru\" ||\n      aux === \"Miru\" ||\n      aux === \"TeIru\";\n  }\n  return verbs;\n}\n\nfunction conjugateAuxiliary(\n  verb: string,\n  aux: Auxiliary,\n  conj: Conjugation,\n  typeII: boolean = false,\n): string[] {\n  if (aux === \"Potential\") {\n    const newverb = conjugateTypeI(verb, \"Conditional\")[0] + \"\u308B\";\n    return conjugate(newverb, conj, true);\n  } else if (aux === \"Masu\") {\n    const base = conjugate(verb, \"Conjunctive\", typeII)[0];\n    switch (conj) {\n      case \"Negative\":\n        return [base + \"\u307E\u305B\u3093\", base + \"\u307E\u305B\u3093\u3067\u3057\u305F\"];\n      // case 'Conjunctive':\n      case \"Dictionary\":\n        return [base + \"\u307E\u3059\"];\n      case \"Conditional\":\n        return [base + \"\u307E\u3059\u308C\u3070\"];\n      case \"Imperative\":\n        return [base + \"\u307E\u305B\", base + \"\u307E\u3057\"]; // latter only for nasaru and ossharu\n      case \"Volitional\":\n        return [base + \"\u307E\u3057\u3087\u3046\"];\n      case \"Te\":\n        return [base + \"\u307E\u3057\u3066\"];\n      case \"Ta\":\n        return [base + \"\u307E\u3057\u305F\"];\n      case \"Tara\":\n        return [base + \"\u307E\u3057\u305F\u3089\"];\n      // case 'Tari':\n      default:\n        throw new Error(\"Unhandled conjugation\");\n    }\n  } else if (aux === \"Nai\") {\n    const base = conjugate(verb, \"Negative\", typeII)[0];\n    switch (conj) {\n      case \"Negative\":\n        return [base + \"\u306A\u304F\u306F\u306A\u3044\"];\n      case \"Conjunctive\":\n        return [base + \"\u306A\u304F\"];\n      case \"Dictionary\":\n        return [base + \"\u306A\u3044\"];\n      case \"Conditional\":\n        return [base + \"\u306A\u3051\u308C\u3070\"];\n      // case 'Imperative':\n      // case 'Volitional':\n      case \"Te\":\n        return [base + \"\u306A\u304F\u3066\", base + \"\u306A\u3044\u3067\"]; // only the first is in Kamiya\n      case \"Ta\":\n        return [base + \"\u306A\u304B\u3063\u305F\"];\n      case \"Tara\":\n        return [base + \"\u306A\u304B\u3063\u305F\u3089\"];\n      // case 'Tari':\n      default:\n        throw new Error(\"Unhandled conjugation\");\n    }\n  } else if (aux === \"Tai\") {\n    const base = conjugate(verb, \"Conjunctive\", typeII)[0];\n    switch (conj) {\n      case \"Negative\":\n        return [base + \"\u305F\u304F\u306A\u3044\"];\n      case \"Conjunctive\":\n        return [base + \"\u305F\u304F\"];\n      case \"Dictionary\":\n        return [base + \"\u305F\u3044\"];\n      case \"Conditional\":\n        return [base + \"\u305F\u3051\u308C\u3070\"];\n      // case 'Imperative':\n      // case 'Volitional':\n      case \"Te\":\n        return [base + \"\u305F\u304F\u3066\"];\n      case \"Ta\":\n        return [base + \"\u305F\u304B\u3063\u305F\"];\n      case \"Tara\":\n        return [base + \"\u305F\u304B\u3063\u305F\u3089\"];\n      // case 'Tari':\n      default:\n        throw new Error(\"Unhandled conjugation\");\n    }\n  } else if (aux === \"Tagaru\") {\n    switch (conj) {\n      case \"Conditional\":\n      case \"Imperative\":\n      case \"Volitional\":\n      case \"Tari\":\n        throw new Error(\"Unhandled conjugation\");\n    }\n    const bases = conjugate(verb, \"Conjunctive\", typeII);\n    const tagaruConj = conjugate(\"\u305F\u304C\u308B\", conj, false);\n    return tagaruConj.map((suffix) => bases[0] + suffix);\n  } else if (aux === \"Hoshii\") {\n    const base = conjugate(verb, \"Te\", typeII)[0];\n    switch (conj) {\n      case \"Negative\":\n        return [base + \"\u307B\u3057\u304F\u306A\u3044\"];\n      case \"Conjunctive\":\n        return [base + \"\u307B\u3057\u304F\"];\n      case \"Dictionary\":\n        return [base + \"\u307B\u3057\u3044\"];\n      case \"Conditional\":\n        return [base + \"\u307B\u3057\u3051\u308C\u3070\"];\n      // case 'Imperative':\n      // case 'Volitional':\n      case \"Te\":\n        return [base + \"\u307B\u3057\u304F\u3066\"];\n      case \"Ta\":\n        return [base + \"\u307B\u3057\u304B\u3063\u305F\"];\n      case \"Tara\":\n        return [base + \"\u307B\u3057\u304B\u3063\u305F\u3089\"];\n      // case 'Tari':\n      default:\n        throw new Error(\"Unhandled conjugation\");\n    }\n  } else if (aux === \"Rashii\") {\n    const base1 = conjugate(verb, \"Ta\", typeII)[0];\n    const base2 = verb;\n    const append = (suffix: string) =>\n      [base1, base2].map((prefix) => prefix + suffix);\n    switch (conj) {\n      case \"Negative\":\n        const neg = conjugateAuxiliary(verb, \"Nai\", \"Dictionary\")[0];\n        return [neg + \"\u3089\u3057\u3044\"];\n      case \"Conjunctive\":\n        return append(\"\u3089\u3057\u304F\");\n      case \"Dictionary\":\n        return append(\"\u3089\u3057\u3044\");\n      // case 'Conditional':\n      // case 'Imperative':\n      // case 'Volitional':\n      case \"Te\":\n        return append(\"\u3089\u3057\u304F\u3066\");\n      // case 'Ta':\n      // case 'Tara':\n      // case 'Tari':\n      default:\n        throw new Error(\"Unhandled conjugation\");\n    }\n  } else if (aux === \"SoudaHearsay\") {\n    const base1 = conjugate(verb, \"Ta\", typeII)[0];\n    const base2 = verb; // dictionary form\n    const append = (suffix: string) =>\n      [base1, base2].map((prefix) => prefix + suffix);\n    switch (conj) {\n      // case 'Negative':\n      // case 'Conjunctive':\n      case \"Dictionary\":\n        return append(\"\u305D\u3046\u3060\");\n      // case 'Conditional':\n      // case 'Imperative':\n      // case 'Volitional':\n      // case 'Te':\n      // case 'Ta':\n      // case 'Tara':\n      // case 'Tari':\n      default:\n        throw new Error(\"Unhandled conjugation\");\n    }\n  } else if (aux === \"SoudaConjecture\") {\n    const base = conjugate(verb, \"Conjunctive\", typeII)[0];\n    switch (conj) {\n      // case 'Negative':\n      // case 'Conjunctive':\n      case \"Dictionary\":\n        return [base + \"\u305D\u3046\u3060\", base + \"\u305D\u3046\u3067\u3059\"];\n      case \"Conditional\":\n        return [base + \"\u305D\u3046\u306A\u3089\"];\n      // case 'Imperative':\n      // case 'Volitional':\n      // case 'Te':\n      case \"Ta\":\n        return [base + \"\u305D\u3046\u3060\u3063\u305F\", base + \"\u305D\u3046\u3067\u3057\u305F\"];\n      // case 'Tara':\n      // case 'Tari':\n      default:\n        throw new Error(\"Unhandled conjugation\");\n    }\n  } else if (aux === \"SeruSaseru\" || aux === \"ShortenedCausative\") {\n    if (conj === \"Tara\" || conj === \"Tari\") {\n      throw new Error(\"Unhandled conjugation\");\n    }\n    let newverb;\n    if (verb === \"\u6765\u308B\" || verb === \"\u304F\u308B\") {\n      newverb = (verb[0] === \"\u6765\" ? \"\u6765\" : \"\u3053\") + \"\u3055\u305B\u308B\";\n    } else if (verb === \"\u3059\u308B\") {\n      newverb = \"\u3055\u305B\u308B\";\n    } else if (typeII) {\n      newverb = conjugateTypeII(verb, \"Negative\")[0] + \"\u3055\u305B\u308B\";\n    } else {\n      // type I\n      newverb = conjugateTypeI(verb, \"Negative\")[0] + \"\u305B\u308B\";\n    }\n    if (aux === \"ShortenedCausative\") {\n      newverb = newverb.slice(0, -2) + \"\u3059\";\n      return conjugate(newverb, conj, false);\n    }\n    return conjugate(newverb, conj, true);\n  } else if (aux === \"ReruRareru\") {\n    if (\n      conj === \"Conditional\" ||\n      conj === \"Imperative\" ||\n      conj === \"Volitional\" ||\n      conj === \"Tara\" ||\n      conj === \"Tari\"\n    ) {\n      throw new Error(\"Unhandled conjugation\");\n    }\n    let newverb;\n    if (verb === \"\u6765\u308B\" || verb === \"\u304F\u308B\") {\n      newverb = (verb[0] === \"\u6765\" ? \"\u6765\" : \"\u3053\") + \"\u3089\u308C\u308B\";\n    } else if (verb === \"\u3059\u308B\") {\n      newverb = \"\u3055\u308C\u308B\";\n    } else if (typeII) {\n      newverb = conjugateTypeII(verb, \"Negative\")[0] + \"\u3089\u308C\u308B\";\n    } else {\n      // type I\n      newverb = conjugateTypeI(verb, \"Negative\")[0] + \"\u308C\u308B\";\n    }\n    return conjugate(newverb, conj, true);\n  } else if (aux === \"CausativePassive\") {\n    const newverb =\n      conjugateAuxiliary(verb, \"SeruSaseru\", \"Negative\", typeII)[0] + \"\u3089\u308C\u308B\";\n    return conjugate(newverb, conj, true);\n  } else if (aux === \"ShortenedCausativePassive\") {\n    const newverb =\n      conjugateAuxiliary(verb, \"ShortenedCausative\", \"Negative\", typeII)[0] +\n      \"\u308C\u308B\";\n    return conjugate(newverb, conj, true);\n  } else if (\n    aux === \"Ageru\" ||\n    aux === \"Sashiageru\" ||\n    aux === \"Yaru\" ||\n    aux === \"Morau\" ||\n    aux === \"Itadaku\" ||\n    aux === \"Kureru\" ||\n    aux === \"Kudasaru\" ||\n    aux === \"TeIru\" ||\n    aux === \"TeAru\" ||\n    aux === \"Miru\" ||\n    aux === \"Iku\" ||\n    aux === \"Kuru\" ||\n    aux === \"Oku\" ||\n    aux === \"TeOru\"\n  ) {\n    const vte = conjugate(verb, \"Te\", typeII)[0];\n    const endings: string[] =\n      aux === \"Ageru\"\n        ? [\"\u3042\u3052\u308B\"]\n        : aux === \"Sashiageru\"\n          ? [\"\u5DEE\u3057\u4E0A\u3052\u308B\", \"\u3055\u3057\u3042\u3052\u308B\"]\n          : aux === \"Yaru\"\n            ? [\"\u3084\u308B\"]\n            : aux === \"Morau\"\n              ? [\"\u3082\u3089\u3046\"]\n              : aux === \"Itadaku\"\n                ? [\"\u3044\u305F\u3060\u304F\"]\n                : aux === \"Kureru\"\n                  ? [\"\u304F\u308C\u308B\"]\n                  : aux === \"Kudasaru\"\n                    ? [\"\u304F\u3060\u3055\u308B\"]\n                    : aux === \"TeIru\"\n                      ? [\"\u3044\u308B\", \"\u308B\"]\n                      : aux === \"TeAru\"\n                        ? [\"\u3042\u308B\"]\n                        : aux === \"Miru\"\n                          ? [\"\u307F\u308B\"]\n                          : aux === \"Iku\"\n                            ? [\"\u3044\u304F\"]\n                            : aux === \"Kuru\"\n                              ? [\"\u304F\u308B\"]\n                              : aux === \"Oku\"\n                                ? [\"\u304A\u304F\"]\n                                : aux === \"TeOru\"\n                                  ? [\"\u304A\u308B\"]\n                                  : [];\n    if (!endings[0]) {\n      throw new Error(\"missing ternary\");\n    }\n    if (aux === \"Kuru\") {\n      return conjugate(endings[0], conj).map((suffix) => vte + suffix);\n    }\n    const endingTypeII: boolean =\n      aux === \"Ageru\" ||\n      aux === \"Sashiageru\" ||\n      aux === \"Kureru\" ||\n      aux === \"TeIru\" ||\n      aux === \"Miru\";\n    const newVerbs = endings.map((ending) => vte + ending);\n    if (aux === \"Oku\") {\n      newVerbs.push(\n        vte.slice(0, -1) + (vte.slice(-1) === \"\u3067\" ? \"\u3069\u304F\" : \"\u3068\u304F\"),\n      );\n    } else if (aux === \"Iku\") {\n      newVerbs.push(vte + \"\u304F\");\n    }\n    return newVerbs.flatMap((v) => conjugate(v, conj, endingTypeII));\n  } else if (aux === \"Shimau\") {\n    const vte = conjugate(verb, \"Te\", typeII)[0];\n    const shimau = conjugate(vte + \"\u3057\u307E\u3046\", conj);\n    const noTe = vte.slice(0, -1);\n    // see https://www.sljfaq.org/afaq/colloquial-contractions.html\n    if (vte.endsWith(\"\u3066\")) {\n      // no rendaku\n      const chau = conjugate(noTe + \"\u3061\u3083\u3046\", conj);\n      const chimau = conjugate(noTe + \"\u3061\u307E\u3046\", conj);\n      return shimau.concat(chau).concat(chimau);\n    }\n    const jimau = conjugate(noTe + \"\u3058\u307E\u3046\", conj);\n    const dimau = conjugate(noTe + \"\u3062\u307E\u3046\", conj);\n    return shimau.concat(jimau).concat(dimau);\n  }\n  isNever(aux);\n  throw new Error(\"Unhandled auxiliary\");\n}\nfunction isNever(x: never) {\n  return x;\n}\n\nexport interface Deconjugated {\n  auxiliaries: Auxiliary[];\n  conjugation: Conjugation;\n  result: string[];\n}\nexport function verbDeconjugate(\n  conjugated: string,\n  dictionaryForm: string,\n  typeII = false,\n  maxAuxDepth = Infinity,\n): Deconjugated[] {\n  const hits: Deconjugated[] = [];\n\n  for (const conj of conjugations) {\n    try {\n      const result = conjugate(dictionaryForm, conj, typeII);\n      if (result.includes(conjugated)) {\n        hits.push({ conjugation: conj, auxiliaries: [], result });\n      }\n    } catch {}\n  }\n\n  if (maxAuxDepth <= 0) {\n    return hits;\n  }\n\n  for (const aux of auxiliaries) {\n    for (const conj of conjugations) {\n      try {\n        const result = conjugateAuxiliary(dictionaryForm, aux, conj, typeII);\n        if (result.includes(conjugated)) {\n          hits.push({ conjugation: conj, auxiliaries: [aux], result });\n        }\n      } catch {}\n    }\n  }\n\n  if (maxAuxDepth <= 1) {\n    return hits;\n  }\n\n  const penultimates: Auxiliary[] = [\n    \"Ageru\",\n    \"Sashiageru\",\n    \"Yaru\",\n    \"Morau\",\n    \"Itadaku\",\n    \"Kureru\",\n    \"Kudasaru\",\n    \"Miru\",\n    \"Iku\",\n    \"Kuru\",\n    \"Oku\",\n    \"Shimau\",\n    \"TeIru\",\n    \"TeAru\",\n    \"TeOru\",\n    \"Potential\",\n    \"ReruRareru\",\n    \"SeruSaseru\",\n  ];\n  const depth2Finals: Auxiliary[] = [\n    \"Masu\",\n    \"SoudaConjecture\",\n    \"SoudaHearsay\",\n    \"TeIru\",\n    \"Tai\",\n    \"Nai\",\n    \"Yaru\",\n  ];\n  for (const penultimate of penultimates) {\n    for (const final of depth2Finals) {\n      for (const conj of conjugations) {\n        const auxs = [penultimate, final];\n        try {\n          const result = conjugateAuxiliaries(\n            dictionaryForm,\n            auxs,\n            conj,\n            typeII,\n          );\n          if (result.includes(conjugated)) {\n            hits.push({ conjugation: conj, auxiliaries: auxs, result });\n          }\n        } catch {}\n      }\n    }\n  }\n\n  if (maxAuxDepth <= 2) {\n    return hits;\n  }\n\n  const antepenultimates: Auxiliary[] = [\"SeruSaseru\", \"ReruRareru\", \"Itadaku\"];\n  const depth3Finals: Auxiliary[] = [\"Masu\"];\n  for (const ante of antepenultimates) {\n    for (const penultimate of penultimates) {\n      for (const final of depth3Finals) {\n        for (const conj of conjugations) {\n          const auxs = [ante, penultimate, final];\n          try {\n            const result = conjugateAuxiliaries(\n              dictionaryForm,\n              auxs,\n              conj,\n              typeII,\n            );\n            if (result.includes(conjugated)) {\n              hits.push({ conjugation: conj, auxiliaries: auxs, result });\n            }\n          } catch {}\n        }\n      }\n    }\n  }\n\n  return hits;\n}\n\nexport { adjConjugations, adjConjugate, adjDeconjugate } from \"./adjective\";\n\nexport type { AdjConjugation, AdjDeconjugated } from \"./adjective\";\n"],
  "mappings": "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",
  "names": ["split", "s", "vec", "charToVecIndex", "row", "rowidx", "char", "lookup", "character", "vowel", "idx", "ret", "adjConjugations", "never", "x", "adjConjugate", "adjective", "conj", "iAdjective", "stem", "addSa", "suffix", "adjDeconjugate", "conjugated", "dictionary", "hits", "result", "conjugations", "auxiliaries", "specialCasesRaw", "specialCases", "verb", "conj", "result", "outer", "conjToIdx", "x", "i", "_a", "tteRaw", "tte", "tail", "quad", "conjugateTypeI", "conjugateSuru", "conjugateKuru", "conjugateDa", "conjugateDesu", "specialHit", "head", "idx", "lookup", "tidx", "tteHit", "conjugateTypeII", "ret", "_verb", "conjugateStrict", "typeII", "conjugate", "conjugateAuxiliaries", "initialVerb", "auxs", "finalConj", "initialTypeII", "verbs", "auxIdx", "aux", "prevAux", "heads", "s", "tails", "conjugateAuxiliary", "prefix", "t", "newverb", "base", "bases", "suffix", "base1", "base2", "append", "vte", "endings", "endingTypeII", "newVerbs", "ending", "v", "shimau", "noTe", "chau", "chimau", "jimau", "dimau", "verbDeconjugate", "conjugated", "dictionaryForm", "typeII", "maxAuxDepth", "hits", "conj", "conjugations", "result", "conjugate", "e", "aux", "auxiliaries", "conjugateAuxiliary", "penultimates", "depth2Finals", "penultimate", "final", "auxs", "conjugateAuxiliaries", "antepenultimates", "depth3Finals", "ante"]
}
